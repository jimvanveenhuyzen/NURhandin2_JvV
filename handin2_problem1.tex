\section*{Code of Problem 1}

The code is included below. Like in the previous hand-in, I use code between sub-questions so I found that having one big .py file per problem is the most efficient. The bold text indicates coded functions! 

\lstinputlisting{NURhandin2_1.py}

\section*{Problem 1a}

In this problem we are asked to write a numerical integrator to solve equation (2) of the Hand-in for $A$. The approach I take is as follows. First as the hint says, we must consider what $dV$ is in this case. Triple integration boundaries and the $dV$ indicate we want to take an integral of a volume, with it's boundaries set by the problem. To make life easier, we will use the spherical coordinate system $(r,\theta,\phi)$, where we will in this case define the radius $r$ to be equal to $x$. First, we must take the whole polar and azimuthal angular range in space. These are given by $0 \le \theta \le \pi$ and $0 \le \phi \le 2\pi$ respectively. $n(x)$ is indepedent of these coordinates so they are integrated out relatively easily as will be seen. Furthermore, the problem states we must use a radius of $x = 0$ up to $x_{max} = 5$ if we want to obtain the average total number of satellites. Using the spherical integration element $dV$ = $x^2 sin(\theta)dxd\theta d\phi$, this results in the integral:

\begin{equation}	
	<N_{sat}> = \iiint_{V} n(x)dV = \int_0^{2\pi} \int_0^{\pi} \int_{x=0}^{x_{max}=5} n(x) x^2 dx sin(\theta)d\theta d\phi
	\label{1}
\end{equation}

Now, as instructed we will be using the given parameters for $n(x)$ throughout the problem. Also as is done in the python implemented of van Daalen, we will first solve the integral numerically for a normalisation constant $A$ = 1. We do this because this is essentially the same as dividing out the factor $A$ on both sides of equation \ref{1}. We can then find the value of $A$ by dividing $N_{sat}$ by the result of the integral $N_{sat,A=1}$ we just found. In terms of equations, we first get $<N_{sat}>/A = N_{sat,A=1}$, so we can then find $A =<N_{sat}>/ N_{sat,A=1}$.\\

The method of integration I use is the $\textbf{Romberg integration method}$, in which we combine approximations found using the trapezoid integration method analogous to Neville's algorithm. A very important detail in this problem is that we have to use a semi-open integration method. For our chosen parameter of $a = 2.6$, we get a negative exponent for $x/b$. This means that if we try to insert $x = 0$, $n(x)$ blows up to infinity. To prevent this, we use an integration method that integrates from a semi-open interval (a,b] instead of [a,b]. For the first Romberg approximation, we use the $\textbf{semi-open trapezoid}$ integration method with $N =1000$ points, so excluding this first value for only an approximation will have barely any effect on the final result of the Romberg integration method, thus minimalising the error. Using this method to integrate in the semi open interval (0,5], we find an integration constant value of $A \approx 9.19484$, where more significant values are present in the output below: 

%\lstinputlisting{NURhandin2_problem1.txt}

Note that continuing in the rest of the problem, I will use a redefinition of $n(x)$ with the previous parameters, but instead of $A$ = 1, I will now use the $A \approx 9.19$ we found in this sub-question. This ensures I can use a distrubition with correct normalisation. 

\section*{Problem 1b}

In this problem we are asked to sample the distribution using 10.000 points meant to present random galaxies within the interval $x= 0$ to $x_{max} = 5$. A very important part of this problem is that in order to sample a distribution, we will need to pick a random value in a uniform distribution, $U(0,5)$. I created my $\textbf{Random Number Generator}$ as follows. First, I make a 'simple' Linear Congruential Generator ($\textbf{LCG}$) to transform some input value $I$ into some other random value $I_{out}$. I then combine this with a 64-bit XOR-shift method, which appends to the LCG we just made with some input value. This $\textbf{XOR-shift}$ then again outputs a value, which is then the combination of both LCG and 64-bit XOR-shift, significantly increasing range and 'randomness' of the value. This combination is done using a final function called $\textbf{RNG}$, which takes in input parameters $a_1,a_2,a_3$ to append to the XOR-shift function, the amount of random numbers you want to generate $N$, and some seed to start off with. Note that we change the seed after the first iteration, so only need an initial seed to start us off. The way I decide to obtain enough seeds is by appending this same function using $seed = 123456789$ (random choice) and generating 1 million random numbers to be used as seeds in the coming problems. I choose 1 million because it's significantly higher than 10.000 and thus more than enough for the purposes of this problem. If we would like larger samples than 10.000, then we should simply increase the amount of seeds $N$ to a value where it is several magnitudes above the required random values like in this situation! In conclusion: $\textit{requirement:} \ N_{seed} >> N_{sample}$.\\

Now, we move on to the sampling of this distribution. First and foremost, the distribution is given by $p(x) dx = N(x) dx / <N_{sat}>$. Here $N(x)$ is the number of satellites at a radius $x$, given by $N(x) = 4\pi x^2 n(x)$. In tota using $<N_{sat}>$ = 100, this gives: 

\begin{equation}
	p(x) dx = N(x) dx /<N_{sat}> = 4\pi x^2 n(x) dx/100
\end{equation}

For this I have used the Rejection Sampling method from the lectures. The reason for this is that the distribution $p(x) = 4\pi x^2 n(x)/100$ we are dealing with is quite complex, so inverting these to apply Slice or Transformation sampling is not very practical at all. To do the sampling we use the RNG function we just created to find both an $x$ and $y$ within a Uniform(0,5) distribution for each iteration. For this we append different parts of the array containing 1 million seeds to be used for RNG purposes, namely the start and middle indices respectively. We then check if $y < f(x)$. If this is true, we accept $x$ into the sample. We continue this until we have 10.000 sampled $x$ points. We are sure to return the corresponding $N(x)$ values of the galaxies also so we can plot the points as a comparisong with $p(x)$ and the histogram. As instructed, we use 20 logaritmically scaled bins from $x = 10^{-4}$ to $x = x_{max}$. We make sure to divide by the width of the bin by using the $\textit{density=True}$ argument in the histogram function of Matplotlib. As you can see in the plot below, both profiles agree nicely with each other. 

%add figure! 

\section*{Problem 1c}



%\lstinputlisting{problem1a.txt}